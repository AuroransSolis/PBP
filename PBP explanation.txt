So the host should be broken up into main, IO manager, and TCP handlers (which are separate threads). main should have a task list 
like this:

- check for incoming connection
    - if YES, create TCP handler for incoming connection
    - if NO, carry on
- check for messages on IO manager receiver
    - if 0, send 0 to all TCP handlers (progress query)
    - if 1, send 1 to all TCP handlers (pause)
    - if 2, send 2 to all TCP handlers (play)
    - if 3, send 3 to all TCP handlers (soft terminate [finish all testing for current x value, then quit])
    - if 4, print number of TCP handlers
    - if 5, send 4 to all TCP handlers (hard terminate [quit immediately])
    - ignore anything else
- check to see if any receivers for TCP handlers have been dropped
- repeat all of the above until all TCP handlers have completed execution, or until qs is entered and current x values have been tested, or until qf is entered


main's IO manager should have something like this (spawned with 'spawn_io_manager()'):

- read stdin
    - if input is "qs", send 3 to main thread
    - if input is "qp", send 0 to main thread
    - if input is "pause", send 1 to main thread
    - if input is "play", send 2 to main thread
    - if input is "nc", send 4 to main thread
    - if input is "qf", send 5 to main thread
    - if input is "h", print help dialog
- repeat until main finishes execution


TCP handlers should have a task list like this (spawned with 'spawn_handler_thread()'):

- check to see if it's time to send a heartbeat message
    - if YES, send heartbeat
    - if NO, carry on
- check to see if there's a byte on the TCP stream
    - if YES:
        - read the byte off the stream
        - match the byte (casted to a char)
            - if 'a', the client sent a progress report. Print this out
            - if 'r', the client sent a data request. Reply to this by:
                - get a lock on the iterator
                - match the Option<u64>:
                    - if Some(u64), transmute to bytes and send to client
                    - if None, send 't' then 'f' to the client for "Terminate, Finished"
            - if 's', the client sent a solution. Check this, and if it's valid, print it
            - if 't', the client is terminating. Close the thread
    - if NO, carry on
- check to see if there's an instruction from main on the instruction receiver
    - if YES:
        - match the instruction
            - if 0, the instruction is progress query. Write 'c' then 0 to the client
            - if 1, the instruction is pause. Write 'c' then 1 to the client
            - if 2, the instruction is play. Write 'c' then 2 to the client
            - if 3, the instruction is soft terminate. Write 't' then 's' to the client
            - if 4, the instruction is hard terminate. Write 't' then 'h' to the client
    - if NO, carry on
- repeat until thread closes
- when thread closes, send a message to main over wrap_up_sender


Then the client also has a main and TCP handlers, but no IO manager. main should have a task list like this:

- spawn a constant number of tester threads
- check to see if there's anything to receive on wrap_up_receivers for all threads
    - if a thread has send a message on this channel, mark the thread as inactive
- when all threads are inactive, close main


Each TCP handler's task list should look like this:

- establish connection to host
- main loop:
    - check to see if thread should soft terminate (handled by soft_terminate boolean)
        - if YES, break loop
        - if NO, carry on
    - get X value
        - write 'r' to host to request data
        - read next byte off of TCP stream
        - match byte (casted to a char)
            - if 'x', the next 8 bytes are the x value. Transmute them to a u64, and continue to testing
            - if 'h', respond with 'h'. This is the heartbeat. Repeat getting the X value
            - if 't', match the next byte (casted to a char)
                - if 's', set soft_term to true
                - if 'f', the iterator in the host has finished. Break loop
                - if 'h', hard terminate. Break loop
                - repeat getting X value
            - if 'c', match next byte
                - if 0, the client has received a progress query. Since the client has no X, Y, or Z value, send ['e' as u64, 'r' as u64, 'r' as u64] back
                - if 1, the client has received a pause command. Pause loop:
                    - match next byte on the stream
                        - if 'h', send 'h' back (heartbeat)
                        - if 't', break main loop
                        - if 'x', store new x value until done
                        - if 'c', match next byte
                            - if 0, send ['e' as u64, 'r' as u64, 'r' as u64] back
                            - if 1, ignore
                            - if 2, break pause loop
                            - if 3, break main loop
                            - if 4, break main loop
                - if 2, ignore
                - if 3, break main loop
                - if 4, break main loop
                - repeat getting X value
    - for y in (2..x / 24).map(|y| y * 24)
        - for z in (2..(x - y) / 24).map(|z| z * 24).take_while(|&z| z < y)
            - test (x, y, z)
            - check TCP stream for byte
                - if a byte is available, match byte (casted to char)
                    - if 'c', match next byte from stream
                        - if 0, send current [x, y, z]
                        - if 1, pause. Pause loop:
                            - match next incoming byte on TCP stream (casted to char)
                                - if 'c', match next byte
                                    - if 0, send current [x, y, z]
                                    - if 1, ignore
                                    - if 2, break pause loop
                                - if 't', match next byte (casted to char)
                                    - if 's', set soft_term to true
                                    - if 'h', break main loop
                                    - ignore anything else
                                - if 'h', send 'h' back (heartbeat)
                        - ignore anything else
                    - if 't', match next byte (casted to char)
                        - if 's', set soft_term to true
                        - if 'h', break main loop
                    - if 'h', send 'h' back
                    - ignore anything else
                - if no byte is available, continue
- once main is broken, just close the thread
